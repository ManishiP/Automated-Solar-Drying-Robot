#include <NMEAGPS.h>    // For gps tracking
#include <Wire.h>       //Serial communication
#include <Adafruit_Sensor.h>
#include <Adafruit_HMC5883_U.h>   //magnetometer library
#include <Servo.h>            //servo library
#include <NewPing.h>          //ultrasonic library
#include "DHT.h"          //DHT sensor library

//bh1750 source codes
#define BH_1750F 0x23
#define BH_1750S 0x5C
#define DATA_REG_RESET 0b00000111
#define POWER_DOWN 0b00000000
#define POWER_ON 0b00000001


/* Assign a unique ID to this sensor at the same time */
Adafruit_HMC5883_Unified mag = Adafruit_HMC5883_Unified(12345);

#define gpsPort Serial2     //GPS serial communication port 
NMEAGPS gps;  //Gps object for storing data
gps_fix fix;
gps_fix fixx;

float lx;
float loy;
float lp;
float loq;
bool gpss = false;
bool loctrcd = false;

#define DHTPIN A0     // what pin we're connected to
#define DHTTYPE DHT22   // DHT 22  (AM2302)
DHT dht(DHTPIN, DHTTYPE);

const int LeftMotorForward = 7;// MOTOR CONTROLLING
const int LeftMotorBackward = 6;
const int RightMotorForward = 5;
const int RightMotorBackward = 4;

#define trig A1
#define echo A2
#define Max_distance 200 // used to limit the distance range that the sensor will detect

bool goesForward = false ; // used to check whether the robot is currently moving forward
int distance = 100; // assigned to a default value 100.this will be updated with the actual vaue measured by the sensor

NewPing sonar(trig,echo,Max_distance); // create an instance of NewPIng class, named as sonar anf taken 3 arguments
Servo servo_motor; // instance of Servo class named as servo_motor
Servo servomotor1;//rainshield
Servo servomotor2;//rainshield

int limFlux;
bool hasRain = false;// check whether there is any rain
bool shieldOk = false;// check whether the shield is applied

float hum;  //Stores humidity value
bool cloud = false; //check whether it is a cloud


//BH1750 source codes
enum BH1750Mode {
  CHM = 0b00010000,     //CHM: Continuously H-Resolution Mode
  CHM_2 = 0b00010001,   //CHM_2: Continuously H-Resolution Mode2
  CLM = 0b00010011,     //CLM: Continuously L-Resolution Mode
  OTH = 0b00100000,     //OTH: One Time H-Resolution Mode
  OTH_2 = 0b00100001,   //OTH_2: One Time H-Resolution Mode2
  OTL = 0b00100011      //OTL: One Time L-Resolution Mode
} mode;
float measuringTimeFactor ;


void setup(){
  Wire.begin();
  mode = CHM;
  measuringTimeFactor = 1;
  setMode();
  setMeasuringTime(); 
  delay(200);

  pinMode(LeftMotorForward,OUTPUT);
  pinMode(LeftMotorBackward,OUTPUT);
  pinMode(RightMotorForward,OUTPUT);
  pinMode(RightMotorBackward,OUTPUT);
  pinMode(10, OUTPUT); //PWM
  pinMode(11, OUTPUT); //PWM

  analogWrite(10, 180);
  analogWrite(11, 180);

  servo_motor.attach(9);//attached pin of servo motr for ultrasonic
  servo_motor.write(110);//initial position of the servo motor

  servomotor1.attach(26);//rainshield servos
  servomotor2.attach(28);
  servomotor1.write(0);
  servomotor2.write(180);

  delay(2000);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);
  distance = readPing();
  delay(100);

  Serial.begin(9600);
  dht.begin();

  sensor_t sensor; // magnetometer object
  mag.getSensor(&sensor);

  delay(10000);

  float lx = 0;
  while (gpss == false){        //predefining the gps location
    if (gps.available(gpsPort)) {
      fix = gps.read();

      float lx = fix.latitude(); // positive for N, negative for S
      float loy = fix.longitude(); // positive for E, negative for W      
    }
    if (int(lx) != 0){
      gpss = true;
    }
  }

}

void loop(){
  gpss = false; 
  limFlux = lightCon();  //light conditions (cloudy, half sunny, sunny)

  while (isRain() == false){  //check for rain
    if (isShady() == true){ //check for shade
      selfDrive();  //selfdrive to a random location with higher sunlight
    }
  }

  if (shieldOk == false){   //Activating shield
    Serial.println("Shield On");
    shieldAct();
    delay(3000);
    pathFind();
  }
}

float Heading(){    //Calculating the heading of the robot using HMC 5883L
  sensors_event_t event; 
  mag.getEvent(&event);

  float heading = atan2(event.magnetic.y, event.magnetic.x);
  float declinationAngle = 0.22;
  heading += declinationAngle;

  if(heading < 0){
    heading += 2*PI;
  } 
  // Check for wrap due to addition of declination.
  if(heading > 2*PI){
    heading -= 2*PI;
  }
  // Convert radians to degrees for readability.
  float headingDegrees = heading * 180/M_PI; 
  return headingDegrees;
}

void pathFind(){    // function for location tracing
  float ang;
  bool obs;
  while (loctrcd){
    while (gpss == false){
      lp = 0;
      if (gps.available(gpsPort)){
        fixx = gps.read();

        lp = fixx.latitude(); // positive for N, negative for S
        loq = fixx.longitude(); // positive for E, negative for W
      }
      if (lp != 0){
        gpss = true;
      }
    }

    float latDif = lx-lp;
    float lonDif = loy-loq;

    sensors_event_t event; 
    mag.getEvent(&event);

    float heading = atan2(event.magnetic.y, event.magnetic.x);
    float declinationAngle = 0.036652;
    heading += declinationAngle;
    
    // Correct for when signs are reversed.
    if(heading < 0){
      heading += 2*PI;
    }
      
    // Check for wrap due to addition of declination.
    if(heading > 2*PI){
      heading -= 2*PI;
    }

    float headingDegrees = heading*180/M_PI;

    if (latDif == 0 && lonDif == 0){
      loctrcd = true;
      float ang = 0;
      break;
    }else if (latDif == 0 && lonDif >= 0) {
      float ang = 90;
    }else if (latDif == 0 && lonDif < 0){
      float ang = 270;
    }else if (latDif > 0 && lonDif > 0){
      float p = lonDif/latDif;
      float ang = atan(p)*180/M_PI;
    } else if (latDif >0 && lonDif<0){
      float p = -1*lonDif/latDif;
      float ang = 360 -atan(p)*180/M_PI;
    } else if (latDif <0 && lonDif <0){
      float p = lonDif/latDif;
      float ang = 180 + atan(p)*180/M_PI;
    } else {
      float p = -1*lonDif/latDif;
      float ang = 180 - atan(p)*180/M_PI;
    }

    float rot = ang - headingDegrees;
    
    if (rot > 0){ 
      while (rot > 15){
        turnRightC();
      }
      moveStop();
      delay(300);
    } else if (rot < 0){
      while (rot < -15){
        turnLeftC();
      }
      moveStop();
    }

    unsigned long start_time = millis();

    int dd = readPing();
    delay(300);

    while ( dd>35 && (millis() - start_time) < 1000){
      moveForwardC();
      bool obs = true;
      int dd = readPing();
      delay(300);
    }

    if (obs == true){
      moveStop();
      delay(300);
      moveBackwardC();
      delay(400);
      moveStop();
      delay(400);
      float Distance_Right = lookRight();
      delay(300);
      float Distance_Left = lookLeft();
      delay(300);
      
      if (Distance_Right>=Distance_Left){
        turnRightC();
        delay(500);
        moveStop();
      }
      else{
        turnLeftC();
        delay(500);
        moveStop();
      }  
    }
  }
}

bool isShady(){   //Checking whether there is a shade coming 
  limFlux = lightCon();
  
  float xy = getlux();
  delay(100);
  float yz = getluxS();
  delay(100);
  
  if (xy >= limFlux && yz >= limFlux){    //conditional statements for identifying a cloud
    cloud = false;
    return false;
  } else if (yz < limFlux){
    delay(1500);
    xy = getlux();
    if (xy >= limFlux && cloud == false){
      cloud = false;
      Serial.println("True by sensor 1");
      return true;
    }else{
      cloud = true;
      return false;
    }
  } else if (xy < limFlux){
    delay(1500);
    yz = getluxS();
    if (yz >= limFlux && cloud == false){
      cloud = false;
      Serial.println("True for sensor 2");
      return true;
    }else{
      cloud = true;
      return false;
    }
  }
}

int lightCon(){       //checking the light conditions
  int jk =  analogRead(A4)*20000/1023;
  return 3;
  return jk;
}

float getHum(){
  hum = dht.readHumidity();
  delay(700);
  return hum;
}

bool isRain(){    //checking for rain
  int val = analogRead(A5);
  float h = getHum();
  delay(100);


  if (val <800 || h > 95){ 
    return true;
  } else {
    return false;
  }

}

void shieldAct(){ //Rain shield activating
  for (int i=0; i<170; i++){
    servomotor1.write(i);
    servomotor2.write(180-i);
    delay(15);
  }
  shieldOk = true;
}

void shieldDct(){
  for (int i=180; i>=0; i--){
    servomotor1.write(i);
    servomotor2.write(180-i);
    delay(20);
  }
}

int lookRight(){    //Searching obstacles in right
  int distaance = 0;
  for (int p = 110; p >= 50; p = p-10){
    servo_motor.write(p);
    delay(10);
    int mes = readPing();
    delay(250);
    distaance += mes;
  }
  servo_motor.write(110);
  delay(20);
  return distaance;
}

int lookLeft(){     //Searching obstacles in left
  int distaance = 0;
  for (int p = 110; p <= 170; p = p+10){
    servo_motor.write(p);
    delay(10);
    int mes = readPing();
    delay(250);
    distaance += mes;
  }
  servo_motor.write(110);
  delay(20);
  return distaance;
}

int readPing(){   //returning the distance
  int cm = sonar.ping_cm();
  delay(150);
  if (cm ==0){
    cm = 1;
  }
  return cm;
}

void moveStop(){    //stopping
  digitalWrite(RightMotorForward, LOW);
  digitalWrite(LeftMotorForward, LOW);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, LOW);
  goesForward = false;
}

void moveForward(){   //moving forward
  if (!goesForward){
    goesForward = true;
    digitalWrite(RightMotorForward, LOW);
    digitalWrite(LeftMotorForward, LOW);
    digitalWrite(RightMotorBackward, HIGH);
    digitalWrite(LeftMotorBackward, HIGH);  
  }

}

void moveBackward(){    //moving backward
  goesForward = false;
  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, HIGH);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, LOW);
}

void turnRight(){   //turning to right
  analogWrite(10, 255);
  analogWrite(11, 255);
  digitalWrite(LeftMotorForward, HIGH);
  digitalWrite(RightMotorBackward, HIGH);
  digitalWrite(LeftMotorBackward, LOW);
  digitalWrite(RightMotorForward, LOW);
  
  delay(800);

  digitalWrite(LeftMotorBackward, LOW);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, HIGH);
  
  analogWrite(10, 180);
  analogWrite(11, 180);

}


void turnLeft(){      //turning left
  analogWrite(10, 255);
  analogWrite(11, 255);
  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, LOW);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, HIGH);
  
  delay(800);

  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, HIGH);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, LOW);
  analogWrite(10, 180);
  analogWrite(11, 180);

}


void selfDrive(){   //Self driving
  unsigned long start_time = millis(); // unsigned long store 32 bits long positive numbers
  //millis() returns the number of milliseconds passsed since the arduino board began running the current program
  
  //Loop for 2 s
  while (millis() - start_time < 5000){ //millis() here gives the total time since the code started and start_time is the time
    // at the point the timer started
    int Distance_Right= 0;
    int Distance_Left =0;

    if (distance <=35){
      start_time += 5000;
      moveStop();
      delay(300);
      moveBackward();
      delay(400);
      moveStop();
      delay(400);
      Distance_Right = lookRight();
      delay(300);
      Distance_Left = lookLeft();
      delay(300);
      
      if (Distance_Right>=Distance_Left){
        turnRight();
        moveStop();
      }
      else{
        turnLeft();
        moveStop();
      }
    }
    else{
      moveForward();
    }
    distance=readPing(); 
    delay(250);
  }

  distance = readPing();
  moveStop();

}

float getlux(){   //measuring lux sensor1
  uint16_t rawLux;
  float lux;
  
  rawLux = readBH1750();
  if((mode==CHM_2)||(mode==OTH_2)){
    lux = (rawLux/2.4)/measuringTimeFactor;     
  }
  else{
    lux = (rawLux/1.2)/measuringTimeFactor;
  }
  
  return lux;
}

float getluxS(){  //measuring lux sensor2
  uint16_t rawLuxS;
  float luxS;

  rawLuxS = readBH1750S();
  if((mode==CHM_2)||(mode==OTH_2)){
    luxS = (rawLuxS/2.4)/measuringTimeFactor;     
  }
  else{
    luxS = (rawLuxS/1.2)/measuringTimeFactor;
  }

  return luxS;
}


void powerDown(){
  writeBH1750(POWER_DOWN);
  writeBH1750S(POWER_DOWN);
}
void powerOn(){
  writeBH1750(POWER_ON);
  writeBH1750S(POWER_ON);
  setMode();
}
void dataRegReset(){
  writeBH1750(DATA_REG_RESET);
  writeBH1750S(DATA_REG_RESET);
}
void setMode(){
  writeBH1750(mode);
  writeBH1750S(mode);
}
void setMeasuringTime(){
  byte mt = round(measuringTimeFactor*69);
  byte highByteMT = ((mt>>5) | 0b01000000);
  byte lowByteMT = (mt & 0b01111111);
  lowByteMT |= 0b01100000;
  writeBH1750(highByteMT);
  writeBH1750(lowByteMT);
  writeBH1750S(highByteMT);
  writeBH1750S(lowByteMT);
}
uint16_t readBH1750(){
  uint8_t MSbyte, LSbyte;
  Wire.requestFrom(BH_1750F, 2);
  if(Wire.available()){
    MSbyte=Wire.read();
    LSbyte=Wire.read(); 
  }
  return ((MSbyte<<8) + LSbyte);
}
void writeBH1750(byte val){
  Wire.beginTransmission(BH_1750F);
  Wire.write(val);
  Wire.endTransmission();
}
uint16_t readBH1750S(){
  uint8_t MSbyte, LSbyte;
  Wire.requestFrom(BH_1750S, 2);
  if(Wire.available()){
    MSbyte=Wire.read();
    LSbyte=Wire.read(); 
  }
  return ((MSbyte<<8) + LSbyte);
}
void writeBH1750S(byte val){
  Wire.beginTransmission(BH_1750S);
  Wire.write(val);
  Wire.endTransmission();
}

void moveForwardC(){    //gps tracing
  if (!goesForward){
    goesForward = true;
    digitalWrite(RightMotorForward, LOW);
    digitalWrite(LeftMotorForward, LOW);
    digitalWrite(RightMotorBackward, HIGH);
    digitalWrite(LeftMotorBackward, HIGH);  
  }

}

void moveBackwardC(){
  goesForward = false;
  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, HIGH);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, LOW);
}

void turnRightC(){
  digitalWrite(LeftMotorForward, HIGH);
  digitalWrite(RightMotorBackward, HIGH);
  digitalWrite(RightMotorForward, LOW);
  digitalWrite(LeftMotorBackward, LOW);
}


void turnLeftC(){
  digitalWrite(RightMotorForward, HIGH);
  digitalWrite(LeftMotorForward, LOW);
  digitalWrite(RightMotorBackward, LOW);
  digitalWrite(LeftMotorBackward, HIGH);
}
